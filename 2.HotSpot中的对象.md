## HotSpot 虚拟机中的对象
### 1. 对象创建过程（在遇到一条 new 指令时）
1. 检查该指令的参数是否能在**常量池**中定位到一个类的**符号引用**，并且检查这个符号引用代表的类是否已被**加载、解析、初始化**过。若没有，则先执行类加载过程。
2. 类加载检查通过后，将分配内存。对象所需的内存大小在类加载后即可确定，如何划分相应大小的内存？
    
    - 指针碰撞(Bump the Pointer)。假设 JVM 中的内存**绝对规整**，则**维护一个指针**，使得用过的内存在指针的一侧，空闲的内存在指针的另一侧。在分配内存时，只需将指针向空闲内存的一侧移动相应大小的距离。
    - 空闲列表（Free List）。假设 JVM 中的内存**不规整**。则需要**维护一个表**，记录用过的内存位置以及空闲的内存位置。在分配内存时，从表中找到合适大小的内存进行分配，同时更新表。

3. 当多个线程操作指针或者更新空闲列表时，会发生**线程不安全**问题。有两种方案：
    
    - 对分配内存空间的动作进行同步处理——实际上 JVM 采用 CAS + 失败重试来保证更新操作的**原子性**。
    - 把分配内存的动作按照线程划分在不同空间中进行，即每个线程**预先从 Java 堆中分配一小块内存**，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。当线程需要分配内存时，先尝试在 TLAB 上分配，只有在 TLAB 用尽需要分配新的 TLAB 时，才需要**同步锁**。

4. 分配完内存后，JVM 将分配到的内存空间都初始化为**零值**（不包括对象头），若使用 TLAB ，该工作也可以提前至 TLAB 分配时进行。
5. 对对象进行必要的设置。如：是哪个类的实例、如何找到类的元数据、哈希码、CG 分代年龄等，保存在对象头中。

***
6. new 指令执行结束后，调用 (init) 方法按照程序员的意愿初始化对象。

### 2. 对象的内存布局
可分为3块区域：**对象头、实例数据、对齐填充**
1. 对象头：包括两部分信息。
    
    - 一部分存储对象自身运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据称谓 Mark Word。
    - 另一部分是类型指针，指向类元数据的指针，JVM 通过这个指针确定对象属于哪个类。另外，如果对象是一个数组，那在对象头中还需要一块用于记录数组长度的数据。
2. 实例数据：是对象真正存储的有效信息，也是程序代码中定义的各种类型的字段内容，包括从父类继承下来的。
3. 对齐填充：并不是必然存在的，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，不满足时需要填充。

### 3. 对象的访问定位
Java 程序需要通过 Java 栈中局部变量表里的 reference 字段的值来寻找 Java 堆中对应的具体对象。寻找方式有两种：
1. 句柄访问：在**Java 堆**中划分一块内存来作为句柄池，此时 reference 字段存储的是对象的句柄地址，句柄中保存了两个信息：**对象实例数据在 Java 堆中的地址、对象类型数据在方法区中的地址**。Java 程序先找到句柄，然后根据句柄分别去堆和方法区中取相应的数据。
2. 直接指针访问：reference 保存的是**对象的地址**，先在 Java 堆中找到对象实例，然后通过**实例中保存的指向对象类型数据的指针**去方法区中寻找对象的类型数据。

HotSpot VM 采用的是直接指针访问。