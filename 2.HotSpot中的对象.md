## HotSpot 虚拟机中的对象
### 1. 对象创建过程（在遇到一条 new 指令时）
1. 检查该指令的参数是否能在**常量池**中定位到一个类的**符号引用**，并且检查这个符号引用代表的类是否已被**加载、解析、初始化**过。若没有，则先执行类加载过程。
2. 类加载检查通过后，将分配内存。对象所需的内存大小在类加载后即可确定，如何划分相应大小的内存？
    
    - 指针碰撞(Bump the Pointer)。假设 JVM 中的内存**绝对规整**，则**维护一个指针**，使得用过的内存在指针的一侧，空闲的内存在指针的另一侧。在分配内存时，只需将指针向空闲内存的一侧移动相应大小的距离。
    - 空闲列表（Free List）。假设 JVM 中的内存**不规整**。则需要**维护一个表**，记录用过的内存位置以及空闲的内存位置。在分配内存时，从表中找到合适大小的内存进行分配，同时更新表。

3. 当多个线程操作指针或者更新空闲列表时，会发生**线程不安全**问题。有两种方案：
    
    - 对分配内存空间的动作进行同步处理——实际上 JVM 采用 CAS + 失败重试来保证更新操作的**原子性**。
    - 把分配内存的动作按照线程划分在不同空间中进行，即每个线程**预先从 Java 堆中分配一小块内存**，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。当线程需要分配内存时，先尝试在 TLAB 上分配，只有在 TLAB 用尽需要分配新的 TLAB 时，才需要**同步锁**。

4. 分配完内存后，JVM 将分配到的内存空间都初始化为**零值**（不包括对象头），若使用 TLAB ，该工作也可以提前至 TLAB 分配时进行。
5. 对对象进行必要的设置。如：是哪个类的实例、如何找到类的元数据、哈希码、CG 分代年龄等，保存在对象头中。

***
6. new 指令执行结束后，调用 (init) 方法按照程序员的意愿初始化对象。