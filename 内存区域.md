## Java虚拟机运行时数据区
#### 主要包括：
1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. Java堆
5. 方法区

### 1. 程序计数器
只占用一块较小的内存空间，是当前线程所执行的字节码的**行号指示器**。

每条线程都有一个独立的程序计数器，属于**“线程私有”**的内存。

如果正在执行的是Java方法，则该计数器记录的是**当前正在执行**的虚拟机字节码指令的地址；如果正在执行的是Native方法，则该计数器值为空（Undefined）。*此区域是唯一一个没有规定任何OutOfMemoryError情况的区域。*

### 2. Java 虚拟机栈
与程序计数器一样，Java 虚拟机栈也是**线程私有**的内存区域，其生命周期与线程相同。虚拟机栈描述的是**Java 方法执行**的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法接口等信息。每一个方法从**调用**直至**执行完成**，就对应着一个栈帧在虚拟机栈中**入栈**到**出栈**的过程。

该区域有两种异常状况：如果线程请求的栈深度大于虚拟机允许的栈深度，将抛出 StackOverFlow 的异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 的异常。

### 3. 本地方法栈
本地方法栈与虚拟机栈的作用类似，只是本地方法栈为虚拟机使用到的 Native 方法服务。也会抛出 StackOverFlow 与 OutOfMemoryError 两种异常。

### 4. Java 堆
对大多数应用来说，Java 堆通常是 JVM 所管理的内存中最大的一块，被**所有线程共享**，在虚拟机启动时创建。该区域的唯一目的就是**存放对象实例**。是垃圾收集器管理的主要区域，也被称为“ GC 堆”。

Java 堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。实现时，可以是固定的，也可以是可扩展的。如果在堆中没有足够的内存完成实例的分配，并且也无法再扩展时，就会抛出 OutOfMemoryError 异常。

### 5. 方法区
与 Java 堆一样，也是**所有线程共享**的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

该区域的垃圾收集行为比较少，主要针对常量池的回收和对类型的卸载。当无法满足内存分配的需求时，就会抛出 OutOfMemoryError 异常。

### 6. 运行时常量池

