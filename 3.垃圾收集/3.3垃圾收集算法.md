## 3.3 垃圾收集算法
### 1. 标记-清楚算法
最基础的垃圾收集算法，分为**标记、清除**两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。其中标记通常需要两个阶段：第一次标记所有无引用链的对象，然后检查是否有必要执行 finalize() 方法，需要的加入 F-Queue 队列等待执行；第二次标记针对 F-Queue 中的对象，若有的对象在 finalize() 方法中又把自己加到了引用链中（极不推荐这么做），则此时可以逃脱被标记的命运。两次都被标记的对象将被清楚。

主要不足有两点：一是**效率**问题，标记和清楚两个阶段的效率都不高；二是**空间**问题，标记清楚后将产生大量不连续的内存碎片，过多的碎片会导致在之后需要分配较大对象时，无法找到连续内存而不得不提前出发一次垃圾回收。

### 2. 复制算法
解决**效率问题**。将内存空间**一分为二**，每次**只使用其中一块**。对于使用中的块，每次进行顺序分配（所以必然会用尽），当这一块的内存用尽后，先把存活的对象**复制到另一块**上，再把已使用过的空间一次性**全部清理**。这样一来，**每次都是对整个半区进行回收**，不必再考虑内存碎片的问题，在内存分配时只需采用“指针碰撞”方法移动指针即可。

HotSpot VM 就是采用复制算法来回收新生代。IBM 的研究认为新生代中的对象有 98% 都是“朝生夕死”，所以不需要按照 1:1 来划分空间，而是将内存划分为**一块较大的 Eden 空间和两块较小的 Survivor 空间**，每次**使用 Eden 和其中一块 Survivor**。回收时，将存活的对象复制到**另一块 Survivor 中**，清理刚才使用的 Eden 和 Survivor。通常 Eden 与 Survivor 的比例为 8:1 。当然，没办法保证每次都只有不多于 10% 的对象存活，当 Survivor 空间不够时，还需要依赖其他内存（老年代）进行**分配担保**。

### 3. 标记-整理算法
复制算法在对象存活率高的情况下需要进行较多的复制，效率会变低，另外就是还需要老年代进行分配担保，以应对对象 100% 存活的极端现象，一般在老年代中就不能继续使用复制算法了。

标记-整理算法的标记过程与标记-清楚算法的一样，不过后续步骤不是直接对可回收对象进行清理，而是先把存活的对象都聚集到一端，然后再直接清理掉端边界以外的所有内存。

***
### 4. 总结
当前商业 VM 的垃圾收集都采用“分代收集”，综合以上所有算法。根据对象存活周期的不同将内存划分为几块，通常是把 Java 堆划分为**新生代和老年代**。对于**新生代**，对象存活率低，采用**复制算法**。对于**老年代**，对象存活率高，采用**标记-清除或标记-整理算法**。